<!doctype html>
<html lang="zh" class="no-js">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.75.1" />

<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">



<link rel="shortcut icon" href="/favicons/favicon.ico" >
<link rel="apple-touch-icon" href="/sig-envoy/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="icon" type="image/png" href="/sig-envoy/favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="/sig-envoy/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/sig-envoy/favicons/android-36x36.png" sizes="36x36">
<link rel="icon" type="image/png" href="/sig-envoy/favicons/android-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="/sig-envoy/favicons/android-72x72.png" sizes="72x72">
<link rel="icon" type="image/png" href="/sig-envoy/favicons/android-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/sig-envoy/favicons/android-144x144.png" sizes="144x144">
<link rel="icon" type="image/png" href="/sig-envoy/favicons/android-192x192.png" sizes="192x192">

<title>Envoy源码分析之ThreadLocal机制 | Envoy SIG</title><meta property="og:title" content="Envoy源码分析之ThreadLocal机制" />
<meta property="og:description" content="Envoy中的`ThreadLocal`机制其实就是我们经常说的线程本地存储简称TLS(Thread Local Storage)，顾名思义通过TLS定义的变量会在每一个线程专有的存储区域存储一份，访问TLS的时候，其实访问的是当前线程占有存储区域中的副本，因此可以使得线程可以无锁的并发访问同一个变量。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cloudnative.to/sig-envoy/blog/2020/08/23/envoy%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bthreadlocal%E6%9C%BA%E5%88%B6/" />
<meta property="article:published_time" content="2020-08-23T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-12-04T08:20:58+00:00" /><meta property="og:site_name" content="Envoy SIG" />
<meta itemprop="name" content="Envoy源码分析之ThreadLocal机制">
<meta itemprop="description" content="Envoy中的`ThreadLocal`机制其实就是我们经常说的线程本地存储简称TLS(Thread Local Storage)，顾名思义通过TLS定义的变量会在每一个线程专有的存储区域存储一份，访问TLS的时候，其实访问的是当前线程占有存储区域中的副本，因此可以使得线程可以无锁的并发访问同一个变量。">
<meta itemprop="datePublished" content="2020-08-23T00:00:00+00:00" />
<meta itemprop="dateModified" content="2020-12-04T08:20:58+00:00" />
<meta itemprop="wordCount" content="288">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Envoy源码分析之ThreadLocal机制"/>
<meta name="twitter:description" content="Envoy中的`ThreadLocal`机制其实就是我们经常说的线程本地存储简称TLS(Thread Local Storage)，顾名思义通过TLS定义的变量会在每一个线程专有的存储区域存储一份，访问TLS的时候，其实访问的是当前线程占有存储区域中的副本，因此可以使得线程可以无锁的并发访问同一个变量。"/>





<link rel="preload" href="/sig-envoy/scss/main.min.1b0fe2bdad95a48b1637110ca7984f00e1e84f9e71e1009c4a18132806282673.css" as="style">
<link href="/sig-envoy/scss/main.min.1b0fe2bdad95a48b1637110ca7984f00e1e84f9e71e1009c4a18132806282673.css" rel="stylesheet" integrity="">


  <script src="/js/jquery-3.5.1.min.js"></script>

  <script src="/js/lunr.min.js"></script>





  </head>
  <body class="td-page td-blog">
    <header>
      
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar">
    <a class="navbar-brand" href="/sig-envoy/">
        <span class="navbar-logo">
        <span class="text-uppercase font-weight-bold">Envoy SIG</span> 
    </a>
    <div class="td-navbar-nav-scroll ml-md-auto" id="main_navbar">
        <ul class="navbar-nav mt-2 mt-lg-0">
             
            <li class="nav-item mr-4 mb-2 mb-lg-0">
                     
                <a class="nav-link active" href="/sig-envoy/blog/" >
                    <span class="active" >博客</span>
                </a>
            </li>
            
            <li class="nav-item mr-4 mb-2 mb-lg-0">
                     
                <a class="nav-link" href="/sig-envoy/docs/community/" >
                    <span>社区</span>
                </a>
            </li>
            
            <li class="nav-item mr-4 mb-2 mb-lg-0">
                     
                <a class="nav-link" href="/sig-envoy/docs/" >
                    <span>文档</span>
                </a>
            </li>
              
        </ul>
    </div>
    <div class="navbar-nav d-none d-lg-block">
<input type="search" class="form-control td-search-input" placeholder="&#xf002 站内搜索…" aria-label="站内搜索…" autocomplete="off">

</div>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
            




<div id="td-sidebar-menu" class="td-sidebar__inner">
  
  <form class="td-sidebar__search d-flex align-items-center">
    
<input type="search" class="form-control td-search-input" placeholder="&#xf002 站内搜索…" aria-label="站内搜索…" autocomplete="off">


    <button class="btn btn-link td-sidebar__toggle d-md-none p-0 ml-3 fas fa-bars" type="button" data-toggle="collapse" data-target="#td-section-nav" aria-controls="td-docs-nav" aria-expanded="false" aria-label="Toggle section navigation">
    </button>
  </form>
  
  <nav class="collapse td-sidebar-nav" id="td-section-nav">
    
    






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/sig-envoy/blog/" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">博客</a>
  </li>
  <ul>
    <li class="collapse show" id="sig-envoyblog">
      
      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/sig-envoy/blog/startup/" class="align-left pl-0 pr-2 collapsed td-sidebar-link td-sidebar-link__section">新手上路系列</a>
  </li>
  <ul>
    <li class="collapse " id="sig-envoyblogstartup">
      
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-sig-envoyblog20200925e58996e69e90envoy-filtere79a84bazele7bc96e8af91e9858de7bdae" href="/sig-envoy/blog/2020/09/25/%E5%89%96%E6%9E%90envoy-filter%E7%9A%84bazel%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE/">剖析Envoy Filter的Bazel编译配置</a>
      
      
    </li>
  </ul>
</ul>

      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/sig-envoy/blog/translation/" class="align-left pl-0 pr-2 collapsed td-sidebar-link td-sidebar-link__section">好文翻译系列</a>
  </li>
  <ul>
    <li class="collapse " id="sig-envoyblogtranslation">
      
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-sig-envoyblog20200510e5a682e4bd95e4b8ba-envoy-e69e84e5bbbae4b880e4b8aae68ea7e588b6e99da2e69da5e7aea1e79086e99b86e7bea4e7bd91e7bb9ce6b581e9878f" href="/sig-envoy/blog/2020/05/10/%E5%A6%82%E4%BD%95%E4%B8%BA-envoy-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%A5%E7%AE%A1%E7%90%86%E9%9B%86%E7%BE%A4%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F/">如何为 Envoy 构建一个控制面来管理集群网络流量</a>
      
      
    </li>
  </ul>
</ul>

      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/sig-envoy/blog/code/" class="align-left pl-0 pr-2 active td-sidebar-link td-sidebar-link__section">源码分析系列</a>
  </li>
  <ul>
    <li class="collapse show" id="sig-envoyblogcode">
      
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-sig-envoyblog20200823envoye6ba90e7a081e58886e69e90e4b98bdispatchere69cbae588b6" href="/sig-envoy/blog/2020/08/23/envoy%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bdispatcher%E6%9C%BA%E5%88%B6/">Envoy源码分析之Dispatcher机制</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page  active" id="m-sig-envoyblog20200823envoye6ba90e7a081e58886e69e90e4b98bthreadlocale69cbae588b6" href="/sig-envoy/blog/2020/08/23/envoy%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bthreadlocal%E6%9C%BA%E5%88%B6/">Envoy源码分析之ThreadLocal机制</a>
      
      
    </li>
  </ul>
</ul>

      
      
    </li>
  </ul>
</ul>

  </nav>
</div>




          </div>
          <div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
            






<div class="td-page-meta ml-2 pb-1 pt-2 mb-0">





<a href="https://github.com/cloudnativeto/sig-envoy/edit/master/content/zh/blog/code/thread_local.md" target="_blank"><i class="fa fa-edit fa-fw"></i> 编辑此页</a>
<a href="https://github.com/cloudnativeto/sig-envoy/issues/new?title=Envoy%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%e4%b9%8bThreadLocal%e6%9c%ba%e5%88%b6" target="_blank"><i class="fab fa-github fa-fw"></i> 提交文档问题</a>


<a href="https://github.com/cloudnativeto/sig-envoy/issues/new" target="_blank"><i class="fas fa-tasks fa-fw"></i> 提交项目问题</a>

</div>








          </div>
          <main class="col-12 col-md-9 col-xl-8 pl-md-5 pr-md-4" role="main">
            <a class="btn btn-lg -bg-orange td-rss-button d-none d-lg-block" href="https://cloudnative.to/sig-envoy/blog/code/index.xml" target="_blank">
              RSS <i class="fa fa-rss ml-2 "></i>
            </a>
            
<div class="td-content">
	<h1>Envoy源码分析之ThreadLocal机制</h1>
	<div class="lead">Envoy中的<code>ThreadLocal</code>机制其实就是我们经常说的线程本地存储简称TLS(Thread Local Storage)，顾名思义通过TLS定义的变量会在每一个线程专有的存储区域存储一份，访问TLS的时候，其实访问的是当前线程占有存储区域中的副本，因此可以使得线程可以无锁的并发访问同一个变量。</div>
	<div class="td-byline mb-4">
		
		<time datetime="2020-08-23" class="text-muted">2020年8月23日</time>
	</div>
	<h1 id="threadlocal机制">ThreadLocal机制</h1>
<p>​	Envoy中的<code>ThreadLocal</code>机制其实就是我们经常说的线程本地存储简称TLS(Thread Local Storage)，顾名思义通过TLS定义的变量会在每一个线程专有的存储区域存储一份，访问TLS的时候，其实访问的是当前线程占有存储区域中的副本，因此可以使得线程可以无锁的并发访问同一个变量。Linux上一般有三种方式来定义一个TLS变量。</p>
<ul>
<li>gcc对C语言的扩展<code>__thread</code></li>
<li>pthread库提供的<code>pthread_key_create</code></li>
<li>C++11的<code>std::thread_local</code>关键字</li>
</ul>
<p>​	Envoy的<code>ThreadLocal</code>机制就是在C++11的<code>std::thread_local</code>基础上进行了封装用于实现线程间的数据共享。Envoy因其配置的动态生效而出名，而配置动态生效的基石就是<code>ThreadLocal</code>机制，通过<code>ThreadLocal</code>机制将配置可以无锁的在多个线程之间共享，当配置发生变更的时候，通过主线程将更新后的配置Post到各个线程中，交由各个线程来更新自己的<code>ThreadLocal</code>。</p>
<h1 id="threadlocalobject">ThreadLocalObject</h1>
<p>​	Envoy要求所有的<code>ThreadLocal</code>数据对象都要继承<code>ThreadLocalObject</code>，比如下面这个<code>ThreadLocal</code>对象。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">ThreadLocalCachedDate</span> <span style="color:#ce5c00;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">public</span> <span style="color:#000">ThreadLocal</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">ThreadLocalObject</span> <span style="color:#000;font-weight:bold">{</span>
   <span style="color:#000">ThreadLocalCachedDate</span><span style="color:#000;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">const</span> <span style="color:#000">std</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">string</span><span style="color:#ce5c00;font-weight:bold">&amp;</span> <span style="color:#000">date_string</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">:</span> 
   <span style="color:#000">date_string_</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">date_string</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{}</span>
  <span style="color:#204a87;font-weight:bold">const</span> <span style="color:#000">std</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">string</span> <span style="color:#000">date_string_</span><span style="color:#000;font-weight:bold">;</span>
<span style="color:#000;font-weight:bold">};</span>
</code></pre></div><p>​	但实际上<code>ThreadLocalObject</code>只是一个空的接口类，所以并非我们继承了<code>ThreadLocalObject</code>就是一个TLS了。继承<code>ThreadLocalObject</code>目的是为了可以统一对所有要进行TLS的对象进行管理。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#204a87;font-weight:bold">class</span> <span style="color:#000">ThreadLocalObject</span> <span style="color:#000;font-weight:bold">{</span>
<span style="color:#204a87;font-weight:bold">public</span><span style="color:#ce5c00;font-weight:bold">:</span>
  <span style="color:#204a87;font-weight:bold">virtual</span> <span style="color:#ce5c00;font-weight:bold">~</span><span style="color:#000">ThreadLocalObject</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#204a87;font-weight:bold">default</span><span style="color:#000;font-weight:bold">;</span>
<span style="color:#000;font-weight:bold">};</span>
<span style="color:#204a87;font-weight:bold">using</span> <span style="color:#000">ThreadLocalObjectSharedPtr</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">std</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">shared_ptr</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">ThreadLocalObject</span><span style="color:#ce5c00;font-weight:bold">&gt;</span><span style="color:#000;font-weight:bold">;</span>
</code></pre></div><p>​	Envoy中需要TLS的数据有很多，最重要的当属配置，随着配置的增多，这类数据所占据的内存也会变得很大，如果每一种配置都声明为TLS会导致不少内存浪费。为此Envoy通过<code>ThreadLocalData</code>将所有要进行TLS的对象都管理起来，然后将<code>ThreadLocalData</code>本身设置为TLS，通过TLS中保存的指针来访问对应的数据。这样就可以避免直接在TLS中保存数据而带来内存上的浪费，只需要保存指向数据的指针即可，相关代码如下。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">ThreadLocalData</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#8f5902;font-style:italic">// 指向当前线程的Dispatcher对象 
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">Event</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">Dispatcher</span><span style="color:#ce5c00;font-weight:bold">*</span> <span style="color:#000">dispatcher_</span><span style="color:#000;font-weight:bold">{};</span>
  <span style="color:#8f5902;font-style:italic">// 保存了所有要TLS的数据对象的智能指针，通过智能指针来访问真正的数据对象
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">std</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">vector</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">ThreadLocalObjectSharedPtr</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">data_</span><span style="color:#000;font-weight:bold">;</span>
<span style="color:#000;font-weight:bold">};</span>
</code></pre></div><p><img src="https://ata2-img.oss-cn-zhangjiakou.aliyuncs.com/a4712346b33dc89bc09bb5c41332c5ba.jpg" alt="4-2.jpg"></p>
<pre><code>如上图所示，每一个TLS通过指针指向实际的对象，每一个数据对象只在内存中保存一份，避免内存上的浪费，但是这样带来问题就是如何做到线程安全的访问数据对象呢?  当我们要访问数据对象的时候，如果此时正在对数据对象进行更新，这个时候就会存在一个线程安全的问题了。Envoy巧妙的通过在数据对象更新的时候，先构造出一个新的数据对象，然后将TLS中的数据对象指针指向新的数据对象来实现线程安全的访问。本质上和COW(copy-on-write)很类似，但是存在两点区别。
</code></pre>
<ul>
<li>COW中是先拷贝原来的对象，然后更改对象，而Envoy在这里是重新构建一个新的数据对象</li>
<li>COW中无论是读还是写，在更改<code>shared_ptr</code>指向时，都需要加锁，因为<code>shared_ptr</code>本身的读写时非线程安全的，而Envoy不需要加锁。</li>
</ul>
<p>​	Envoy中指向数据对象的<code>shared_ptr</code>并非只有一个，而是每一个线程都有一个<code>shared_ptr</code>指向数据对象，更改<code>shared_ptr</code>指向新的数据对象时通过post一个任务到对应线程中，然后在同一个线程使<code>shared_ptr</code>指向新的数据对象，因此并没有多线程操作<code>shared_ptr</code>，所以没有线程安全问题，自然也不用加锁，这是Envoy实现比较巧妙的地方。</p>
<p><img src="https://ata2-img.oss-cn-zhangjiakou.aliyuncs.com/b1b456618697f8df6c2a0e81bba4a907.jpg" alt="4-3.jpg"></p>
<p>​	如上图所示，T1时刻，Thread1通过TLS对象访问<code>ThreadLocalObjectOld</code>，在T2时刻在main线程发现配置发生了变化，重新构造了一个新的<code>ThreadlocalObjectNew</code>对象，然后通过Thread1的<code>Dispatcher</code>对象post了一个任务到Thread1线程，到了T3时刻这个任务开始执行，将对应的指针指向了 <code>ThreadLocalObjectNew</code>，最后在T4时刻再次访问配置的时候，就已经访问的是最新的配置了。到此为止就完成了一次配置更新，而且整个过程是线程安全的。</p>
<h1 id="threadlocal">ThreadLocal</h1>
<p>​	终于到了分析真正的ThreadLocal对象的时候，它的功能其实很简单，大部分的能力都是依赖<code>Dispatcher</code>、还有上文中提到的<code>SlotImpl</code>、<code>ThreadLocalData</code>等，<code>Instance</code>是它的接口类，它继承了<code>SlotAllocator</code>接口，也包含了上文中分析的<code>allocateSlot</code>方法。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#204a87;font-weight:bold">class</span> <span style="color:#000">Instance</span> <span style="color:#ce5c00;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">public</span> <span style="color:#000">SlotAllocator</span> <span style="color:#000;font-weight:bold">{</span>
<span style="color:#204a87;font-weight:bold">public</span><span style="color:#ce5c00;font-weight:bold">:</span>
  <span style="color:#8f5902;font-style:italic">// 每启动一个worker线程就需要通过这个方法进行注册
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">virtual</span> <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">registerThread</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">Event</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">Dispatcher</span><span style="color:#ce5c00;font-weight:bold">&amp;</span> <span style="color:#000">dispatcher</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#204a87;font-weight:bold">bool</span> <span style="color:#000">main_thread</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#000">PURE</span><span style="color:#000;font-weight:bold">;</span>
  <span style="color:#8f5902;font-style:italic">// 主线程在退出的时候调用，用于标记shutdown状态
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">virtual</span> <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">shutdownGlobalThreading</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000">PURE</span><span style="color:#000;font-weight:bold">;</span>
  <span style="color:#8f5902;font-style:italic">// 每一个worker线程需要调用这个方法来释放自己的TLS
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">virtual</span> <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">shutdownThread</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000">PURE</span><span style="color:#000;font-weight:bold">;</span>
  <span style="color:#204a87;font-weight:bold">virtual</span> <span style="color:#000">Event</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">Dispatcher</span><span style="color:#ce5c00;font-weight:bold">&amp;</span> <span style="color:#000">dispatcher</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000">PURE</span><span style="color:#000;font-weight:bold">;</span>
<span style="color:#000;font-weight:bold">};</span>
</code></pre></div><p>​	对应的实现是<code>InstanceImpl</code>对象，在<code>Instance</code> 的基础上又扩展了一些post任务到所有线程的一些方法。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">
<span style="color:#204a87;font-weight:bold">class</span> <span style="color:#000">InstanceImpl</span> <span style="color:#ce5c00;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">public</span> <span style="color:#000">Instance</span> <span style="color:#000;font-weight:bold">{</span>
 <span style="color:#204a87;font-weight:bold">public</span><span style="color:#ce5c00;font-weight:bold">:</span>
	<span style="color:#000;font-weight:bold">....</span>
 <span style="color:#204a87;font-weight:bold">private</span><span style="color:#ce5c00;font-weight:bold">:</span>
  <span style="color:#8f5902;font-style:italic">// post任务到所有注册的线程中
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">runOnAllThreads</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">Event</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">PostCb</span> <span style="color:#000">cb</span><span style="color:#000;font-weight:bold">);</span>
  <span style="color:#8f5902;font-style:italic">// post任务到所有注册的线程中，完成后通过main_callback进行通知
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">runOnAllThreads</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">Event</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">PostCb</span> <span style="color:#000">cb</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">Event</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">PostCb</span> <span style="color:#000">main_callback</span><span style="color:#000;font-weight:bold">);</span>
  <span style="color:#8f5902;font-style:italic">// 初始化TLS指向对应的数据对象指针
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">static</span> <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">setThreadLocal</span><span style="color:#000;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">uint32_t</span> <span style="color:#000">index</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">ThreadLocalObjectSharedPtr</span> <span style="color:#000">object</span><span style="color:#000;font-weight:bold">);</span>
  <span style="color:#000;font-weight:bold">.....</span>
  <span style="color:#8f5902;font-style:italic">// 保存所有注册的线程
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">std</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">list</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">std</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">reference_wrapper</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">Event</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">Dispatcher</span><span style="color:#ce5c00;font-weight:bold">&gt;&gt;</span> <span style="color:#000">registered_threads_</span><span style="color:#000;font-weight:bold">;</span>
</code></pre></div><p>​	因为所有的线程都会注册都<code>InstanceImpl</code>中，所以只需要遍历所有的线程所对应的<code>Dispatcher</code> 对象，调用其post方法将任务投递到对应线程即可，但是如何做到等所有任务执行完成后进行通知呢 ？</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">InstanceImpl</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">runOnAllThreads</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">Event</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">PostCb</span> <span style="color:#000">cb</span><span style="color:#000;font-weight:bold">,</span> 
                                   <span style="color:#000">Event</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">PostCb</span> <span style="color:#000">all_threads_complete_cb</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#000">ASSERT</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">std</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">this_thread</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">get_id</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#000">main_thread_id_</span><span style="color:#000;font-weight:bold">);</span>
  <span style="color:#000">ASSERT</span><span style="color:#000;font-weight:bold">(</span><span style="color:#ce5c00;font-weight:bold">!</span><span style="color:#000">shutdown_</span><span style="color:#000;font-weight:bold">);</span>
  <span style="color:#8f5902;font-style:italic">// 首先在主线程执行任务
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">cb</span><span style="color:#000;font-weight:bold">();</span>
  <span style="color:#8f5902;font-style:italic">// 利用了shared_ptr自定义析构函数，在析构的时候向主线程post一个完成的通知任务
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#8f5902;font-style:italic">// 这个机制和Bookkeeper的实现机制是一样的。
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">std</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">shared_ptr</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">Event</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">PostCb</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">cb_guard</span><span style="color:#000;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">new</span> <span style="color:#000">Event</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">PostCb</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">cb</span><span style="color:#000;font-weight:bold">),</span>
                   <span style="color:#000;font-weight:bold">[</span><span style="color:#204a87;font-weight:bold">this</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">all_threads_complete_cb</span><span style="color:#000;font-weight:bold">](</span><span style="color:#000">Event</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">PostCb</span><span style="color:#ce5c00;font-weight:bold">*</span> <span style="color:#000">cb</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
                    <span style="color:#000">main_thread_dispatcher_</span><span style="color:#ce5c00;font-weight:bold">-&gt;</span><span style="color:#000">post</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">all_threads_complete_cb</span><span style="color:#000;font-weight:bold">);</span>
                      <span style="color:#204a87;font-weight:bold">delete</span> <span style="color:#000">cb</span><span style="color:#000;font-weight:bold">;</span> <span style="color:#000;font-weight:bold">});</span>

  <span style="color:#204a87;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">Event</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">Dispatcher</span><span style="color:#ce5c00;font-weight:bold">&amp;</span> <span style="color:#f57900">dispatcher</span> <span style="color:#000;font-weight:bold">:</span> <span style="color:#000">registered_threads_</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
    <span style="color:#000">dispatcher</span><span style="color:#000;font-weight:bold">.</span><span style="color:#000">post</span><span style="color:#000;font-weight:bold">([</span><span style="color:#000">cb_guard</span><span style="color:#000;font-weight:bold">]()</span> <span style="color:#ce5c00;font-weight:bold">-&gt;</span> <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">{</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000">cb_guard</span><span style="color:#000;font-weight:bold">)();</span> <span style="color:#000;font-weight:bold">});</span>
  <span style="color:#000;font-weight:bold">}</span>
<span style="color:#000;font-weight:bold">}</span>
</code></pre></div><p>​	通过上面的代码可以看到，这里仍然利用到了<code>shared_ptr</code>的引用计数机制来实现的。每一个post到其他线程的任务都会导致<code>cb_guard</code>引用计数加1，post任务执行完成后<code>cb_guard</code>引用计数减1，等全部任务完成后，<code>cb_guard</code> 的引用计数就变成0了，这个时候就会执行自定义的删除器，在删除器中就会post一个任务到主线程中，从而实现了任务执行完成的通知回调机制。</p>
<p>​	接下来我们来分析下<code>shutdownGlobalThreading</code>，这个函数是用于设置flag来表示正在关闭TLS，必须由主线程在其它worker线程退出之前来调用，调用完成后每一个worker线程还需要调用对应TLS的<code>shutdownThread</code>来清理TLS中的对象，到此为止才完成了全部的TLS清理工作。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">InstanceImpl</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">shutdownGlobalThreading</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#000">ASSERT</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">std</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">this_thread</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">get_id</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#000">main_thread_id_</span><span style="color:#000;font-weight:bold">);</span>
  <span style="color:#000">ASSERT</span><span style="color:#000;font-weight:bold">(</span><span style="color:#ce5c00;font-weight:bold">!</span><span style="color:#000">shutdown_</span><span style="color:#000;font-weight:bold">);</span>
  <span style="color:#000">shutdown_</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#204a87">true</span><span style="color:#000;font-weight:bold">;</span>
<span style="color:#000;font-weight:bold">}</span>
</code></pre></div><p>上面的代码是<code>shutdownGlobalThreading</code>的实现，可以看到仅仅是设置了一个<code>shutdown_</code>的标志。</p>
<p>​	最后来分析一下<code>shutdownThread</code>，每一个work线程在退出事都需要调用这个函数，这个函数会将存储的所有线程存储的对象进行清除。每一个worker线程都持有<code>InstanceImpl</code>实例的引用，在析构的时候会调用<code>shutdownThread</code>来释放自己线程的TLS内容，这个函数的实现如下:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">InstanceImpl</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">shutdownThread</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#000">ASSERT</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">shutdown_</span><span style="color:#000;font-weight:bold">);</span>
  <span style="color:#204a87;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">auto</span> <span style="color:#000">it</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">thread_local_data_</span><span style="color:#000;font-weight:bold">.</span><span style="color:#000">data_</span><span style="color:#000;font-weight:bold">.</span><span style="color:#000">rbegin</span><span style="color:#000;font-weight:bold">();</span> 
	   <span style="color:#000">it</span> <span style="color:#ce5c00;font-weight:bold">!=</span> <span style="color:#000">thread_local_data_</span><span style="color:#000;font-weight:bold">.</span><span style="color:#000">data_</span><span style="color:#000;font-weight:bold">.</span><span style="color:#000">rend</span><span style="color:#000;font-weight:bold">();</span> <span style="color:#ce5c00;font-weight:bold">++</span><span style="color:#000">it</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
    <span style="color:#000">it</span><span style="color:#ce5c00;font-weight:bold">-&gt;</span><span style="color:#000">reset</span><span style="color:#000;font-weight:bold">();</span>
  <span style="color:#000;font-weight:bold">}</span>
  <span style="color:#000">thread_local_data_</span><span style="color:#000;font-weight:bold">.</span><span style="color:#000">data_</span><span style="color:#000;font-weight:bold">.</span><span style="color:#000">clear</span><span style="color:#000;font-weight:bold">();</span>
<span style="color:#000;font-weight:bold">}</span>
</code></pre></div><p>​	比较奇怪的点在于这里是逆序遍历所有的<code>ThreadLocalObject</code>对象来进行reset的，这是因为一些&quot;持久&quot;(活的比较长)的对象如<code>ClusterManagerImpl</code>很早就会创建<code>ThreadLocalObject</code>对象，但是直到shutdown的时候也不析构，而在此基础上依赖<code>ClusterManagerImpl</code>的对象的如<code>GrpcClientImpl</code>等，则是后创建<code>ThreadLocalObject</code>对象，如果<code>ClusterManagerImpl</code>创建的<code>ThreadLocalObject</code>对象先析构，而<code>GrpcClientImpl</code>相关的<code>ThreadLocalObject</code>对象依赖了<code>ClusterManagerImpl</code>相关的TLS内容，那么后析构就会导致未定义的问题。为此这里选择逆序来进行<code>reset</code>，先从一个高层的对象开始，最后才开始对一些基础的对象所关联的<code>ThreadLocalObject</code>进行<code>reset</code>。例如下面这个例子:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#204a87;font-weight:bold">struct</span> <span style="color:#000">ThreadLocalPool</span> <span style="color:#ce5c00;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">public</span> <span style="color:#000">ThreadLocal</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">ThreadLocalObject</span> <span style="color:#000;font-weight:bold">{</span>
	<span style="color:#000;font-weight:bold">.....</span>
  <span style="color:#000">InstanceImpl</span><span style="color:#ce5c00;font-weight:bold">&amp;</span> <span style="color:#000">parent_</span><span style="color:#000;font-weight:bold">;</span>
  <span style="color:#000">Event</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">Dispatcher</span><span style="color:#ce5c00;font-weight:bold">&amp;</span> <span style="color:#000">dispatcher_</span><span style="color:#000;font-weight:bold">;</span>
  <span style="color:#000">Upstream</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">ThreadLocalCluster</span><span style="color:#ce5c00;font-weight:bold">*</span> <span style="color:#000">cluster_</span><span style="color:#000;font-weight:bold">;</span>
	<span style="color:#000;font-weight:bold">.....</span>
<span style="color:#000;font-weight:bold">};</span>
</code></pre></div><p>​	<code>redis_proxy</code>中定义了一个<code>ThreadLocalPool</code>，这个<code>ThreadLocalPool</code>又依赖较为基础的<code>ThreadLocalCluster</code>(是<code>ThreadLocalClusterManagerImpl</code>的数据成员，也就是<code>ClusterManagerImpl</code>所对应的<code>ThreadLocalObject</code>对象)，如果<code>shutdownThread</code>按照顺序的方式析构的话，那么<code>ThreadLocalPool</code>中使用的<code>ThreadLocalCluster</code>会先被析构，然后才是<code>ThreadLocalPool</code>的析构，而<code>ThreadLocalPool</code>析构的时候又会使用到<code>ThreadLocalCluster</code>，但是<code>ThreadLocalCluster</code>已经析构了，这个时候就会出现野指针的问题了。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000">ThreadLocalPool</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">ThreadLocalPool</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">InstanceImpl</span><span style="color:#ce5c00;font-weight:bold">&amp;</span> <span style="color:#000">parent</span><span style="color:#000;font-weight:bold">,</span> 
                                 <span style="color:#000">Event</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">Dispatcher</span><span style="color:#ce5c00;font-weight:bold">&amp;</span> <span style="color:#000">dispatcher</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#204a87;font-weight:bold">const</span> 
                                 <span style="color:#000">std</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">string</span><span style="color:#ce5c00;font-weight:bold">&amp;</span> <span style="color:#000">cluster_name</span><span style="color:#000;font-weight:bold">)</span>
    <span style="color:#ce5c00;font-weight:bold">:</span> <span style="color:#000">parent_</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">parent</span><span style="color:#000;font-weight:bold">),</span> <span style="color:#000">dispatcher_</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">dispatcher</span><span style="color:#000;font-weight:bold">),</span> 
	<span style="color:#000">cluster_</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">parent_</span><span style="color:#000;font-weight:bold">.</span><span style="color:#000">cm_</span><span style="color:#000;font-weight:bold">.</span><span style="color:#000">get</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">cluster_name</span><span style="color:#000;font-weight:bold">))</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#000;font-weight:bold">.....</span>
  <span style="color:#000">local_host_set_member_update_cb_handle_</span> <span style="color:#ce5c00;font-weight:bold">=</span> 
  <span style="color:#000">cluster_</span><span style="color:#ce5c00;font-weight:bold">-&gt;</span><span style="color:#000">prioritySet</span><span style="color:#000;font-weight:bold">().</span><span style="color:#000">addMemberUpdateCb</span><span style="color:#000;font-weight:bold">(</span>
      <span style="color:#000;font-weight:bold">[</span><span style="color:#204a87;font-weight:bold">this</span><span style="color:#000;font-weight:bold">](</span><span style="color:#204a87;font-weight:bold">uint32_t</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#204a87;font-weight:bold">const</span> <span style="color:#000">std</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">vector</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">Upstream</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">HostSharedPtr</span><span style="color:#ce5c00;font-weight:bold">&gt;&amp;</span><span style="color:#000;font-weight:bold">,</span>
             <span style="color:#204a87;font-weight:bold">const</span> <span style="color:#000">std</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">vector</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">Upstream</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">HostSharedPtr</span><span style="color:#ce5c00;font-weight:bold">&gt;&amp;</span> <span style="color:#000">hosts_removed</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">-&gt;</span> <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">{</span>
        <span style="color:#000">onHostsRemoved</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">hosts_removed</span><span style="color:#000;font-weight:bold">);</span>
      <span style="color:#000;font-weight:bold">});</span>
<span style="color:#000;font-weight:bold">}</span>

<span style="color:#000">ThreadLocalPool</span><span style="color:#ce5c00;font-weight:bold">::~</span><span style="color:#000">ThreadLocalPool</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000;font-weight:bold">{</span>
  <span style="color:#8f5902;font-style:italic">// local_host_set_member_update_cb_handle_是ThreadLocalCluster的一部分
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#8f5902;font-style:italic">// ThreadLocalCluster析构会导致local_host_set_member_update_cb_handle_变成野指针
</span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">local_host_set_member_update_cb_handle_</span><span style="color:#ce5c00;font-weight:bold">-&gt;</span><span style="color:#000">remove</span><span style="color:#000;font-weight:bold">();</span>
  <span style="color:#204a87;font-weight:bold">while</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#ce5c00;font-weight:bold">!</span><span style="color:#000">client_map_</span><span style="color:#000;font-weight:bold">.</span><span style="color:#000">empty</span><span style="color:#000;font-weight:bold">())</span> <span style="color:#000;font-weight:bold">{</span>
    <span style="color:#000">client_map_</span><span style="color:#000;font-weight:bold">.</span><span style="color:#000">begin</span><span style="color:#000;font-weight:bold">()</span><span style="color:#ce5c00;font-weight:bold">-&gt;</span><span style="color:#000">second</span><span style="color:#ce5c00;font-weight:bold">-&gt;</span><span style="color:#000">redis_client_</span><span style="color:#ce5c00;font-weight:bold">-&gt;</span><span style="color:#000">close</span><span style="color:#000;font-weight:bold">();</span>
  <span style="color:#000;font-weight:bold">}</span>
<span style="color:#000;font-weight:bold">}</span>
</code></pre></div><p>​	到此为止关于Envoy中的TLS实现就全部分析完毕了。</p>
<h1 id="小结">小结</h1>
<p>​	通过本节的分析相信我们应该足以驾驭Envoy中的<code>ThreadLocal</code>，从其设计可以看出它的一些其巧妙之处，比如抽象出一个<code>Slot</code>和对应的线程存储进行了关联，<code>Slot</code>可以任意传递，因为不包含实际的数据，拷贝的开销很低，只包含了一个索引值，具体关联的线程存储数据是不知道的，避免直接暴露给用户背后的数据。而<code>InstanceImpl</code>对象则管理着所有<code>Slot</code>的分配和移除以及整个<code>ThreadLocal</code>对象的<code>shutdown</code>。还有引入的Bookkeeper机制也甚是巧妙，和<a href="https://envoyproxy-cn.github.io/blog/2020/08/23/envoy%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bdispatcher%E6%9C%BA%E5%88%B6/">Envoy源码分析之Dispatcher机制</a>一文中的<code>DeferredDeletable</code>机制有着异曲同工之妙，通过这个机制可以做到安全的析构<code>SlotImpl</code>对象</p>

	

	
		<br />
		<div id="utter-container"></div>
<script src="https://utteranc.es/client.js"
    repo= 'envoyproxy-cn/comments'
    issue-term= "pathname"
    theme= 'github-light'
    crossorigin= "anonymous"
    async>
</script> 
	

	<ul class="list-unstyled d-flex justify-content-between align-items-center mb-0 pt-5">
  <li>
    <a  class="btn btn-primary  disabled"><span class="mr-1">←</span> 上一页</a>
  </li>
    <a href="/sig-envoy/blog/2020/08/23/envoy%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bdispatcher%E6%9C%BA%E5%88%B6/" class="btn btn-primary ">下一页 <span class="ml-1">→</span></a>
  </li>
</ul>

</div>


          </main>
        </div>
      </div>
      
<footer class="bg-dark py-5 row d-print-none">
  <div class="container-fluid mx-sm-5">
    <div class="row">
      <div class="col-6 col-sm-4 text-xs-center order-sm-2">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="GitHub" aria-label="GitHub">
    <a class="text-white" target="_blank" href="https://github.com/cloudnativeto/sig-envoy">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
        
        
        
      </div>
      <div class="col-12 col-sm-4 text-center py-2 order-sm-2">
        <small class="text-white">&copy; 2020 云原生社区-Envoy-SIG All Rights Reserved
        
	
      </div>
    </div>
  </div>
</footer>


    </div>
    
<script src="/js/popper.min.js"></script>
<script src="/js/bootstrap.min.js"></script>









<script src="/sig-envoy/js/main.min.664f21bf5eb0c31ebc661e2616e6c63e0448cec6d5636d869957be423c3cb952.js" integrity="sha256-Zk8hv16wwx68Zh4mFubGPgRIzsbVY22GmVe&#43;Qjw8uVI=" crossorigin="anonymous"></script>





  </body>
</html>